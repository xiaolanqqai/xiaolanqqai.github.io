<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Xiaolan - Secure MM</title>
	<link rel="Shortcut icon" href="../favicon.ico" loading="lazy">
	<link rel="stylesheet" href="../css/bootstrap.min.css">
	<script type="text/javascript" src="../js/jquery-3.5.1.min.js"></script>
	<link rel="stylesheet" type="text/css" href="../css/index.css" />
	<style>
		/* 密码输入区域样式 */
		.password-container {
			max-width: 500px;
			margin: 0 auto;
			padding: 20px;
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 10px;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
		}

		.pattern-container {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 15px;
			margin: 20px 0;
		}

		.pattern-btn {
			width: 80px;
			height: 80px;
			border-radius: 10px;
			font-size: 30px;
			cursor: pointer;
			border: 2px solid #ddd;
			background-color: #f8f9fa;
			transition: all 0.3s ease;
		}

		.pattern-btn:hover {
			transform: scale(1.1);
			border-color: #0d6efd;
			background-color: #e7f3ff;
		}

		.pattern-btn.selected {
			background-color: #0d6efd;
			color: white;
			border-color: #0a58ca;
		}

		/* 密码显示区域样式更新 */
		.password-display {
			font-size: 32px;
			text-align: center;
			margin: 20px 0;
			letter-spacing: 15px;
			font-family: monospace;
			padding: 15px;
			border: 2px solid #ced4da;
			border-radius: 8px;
			background-color: #f8f9fa;
			color: #495057;
			transition: all 0.3s ease;
			min-height: 60px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		/* 错误状态下的密码显示区域 */
		.password-display.error {
			border-color: #dc3545;
			background-color: #fff5f5;
			color: #dc3545;
			box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
		}

		/* 抖动动画 */
		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
			20%, 40%, 60%, 80% { transform: translateX(5px); }
		}

		/* 抖动效果类 */
		.shake {
			animation: shake 0.5s ease-in-out;
		}

		.error-message {
			color: #dc3545;
			text-align: center;
			margin: 10px 0;
			font-weight: 500;
		}

		.lockout-message {
			color: #dc3545;
			text-align: center;
			margin: 10px 0;
			font-weight: bold;
		}

		/* 解密后内容样式 */
		.content-container {
			max-width: 800px;
			margin: 0 auto;
			padding: 20px;
		}

		.mm-entry {
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 8px;
			padding: 15px;
			margin: 10px 0;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		}

		.mm-entry-platform {
			font-size: 18px;
			font-weight: bold;
			color: #0d6efd;
			margin-bottom: 5px;
		}

		.mm-entry-account {
			font-size: 16px;
			margin-bottom: 5px;
		}

		.mm-entry-password {
			font-size: 14px;
			color: #6c757d;
			font-style: italic;
		}

		/* 响应式设计 */
		@media (max-width: 576px) {
			.pattern-container {
				grid-template-columns: repeat(2, 1fr);
			}

			.pattern-btn {
				width: 60px;
				height: 60px;
				font-size: 20px;
			}
		}
	</style>
</head>

<body>
	<div class="z-3 d-flex flex-row position-fixed">
		<button onclick="window.location.href = '../index.html'" type="button" class="btn btn-info shadow mt-3 mx-3" style="width: 100px;"><strong>返回</strong></button>
		<button onclick="window.location.href = 'More.html'" type="button" class="btn btn-info shadow mt-3" style="width: 100px;"><strong>More</strong></button>
	</div>

	<div class="z-2 d-flex flex-column mx-auto mt-5 pt-2">
		<!-- 密码输入区域 -->
		<div id="password-section" class="mt-10">
			<div class="password-container">
				<h3 class="text-center mb-4">解密 MM 数据</h3>
				<p class="text-center mb-4">请点击四位数图案密码 (A: □, B: △, C: ◇, D: ★)</p>
				<div class="password-display" id="password-display">____</div>
				<div class="pattern-container" id="pattern-container"></div>
				<div class="error-message" id="error-message"></div>
				<div class="lockout-message" id="lockout-message"></div>
				<button id="clear-btn" class="btn btn-secondary w-100 mt-2">清除</button>
			</div>
		</div>

		<!-- 解密后内容区域 -->
		<div id="content-section" class="content-container" style="display: none;">
			<h3 class="text-center mb-4">MM 数据</h3>
			<div id="mm-content"></div>
		</div>

		<div class="fixed-bottom mx-1">
			<div class=" container-fluid">
				<div class="float-end">
					<span class="badge text-black-50">
						<a href="https://xiaolanqqai-sturdy-journey-97xqj446r6wfpw6v.github.dev/" rel="nofollow" target="_blank">Dev</a> • 
						<a id="uptime1" href="Develop.html">加载中...</a>
					</span>
					<span id="state1" class="badge text-bg-success">加载中...</span>
					<a><div class="spinner-grow spinner-grow-sm text-info" role="status"></div></a>
				</div>
			</div>
		</div>
	</div>

	<!-- 动态背景 -->
	<div class="z-1">
		<div class="z-4">
			<div id="jsi-flying-fish-container" class="w-100"></div>
			<script src="../js/fish.js"></script>
		</div>
		<canvas class="background"></canvas>
	</div>
	<script src="../js/particles.min.js"></script>
	<script>
		$('img').on("error", function () {
			$(this).attr('src', '../img/index.png');
		});
	</script>
	<script src="../js/foot.js"></script>

	<!-- 加密解密功能 -->
	<script>
		// 全局变量
		let currentPassword = '';
		let patternOrder = ['A', 'B', 'C', 'D'];
		let errorCount = 0;
		let lockoutUntil = null;
		const MAX_ERRORS = 3;
		const LOCKOUT_DURATION = 24 * 60 * 60 * 1000; // 24小时

		// AES 加密工具类
		class AESUtil {
			static generateKey(password, salt) {
				const encoder = new TextEncoder();
				const keyMaterial = encoder.encode(password);
				const saltBuffer = encoder.encode(salt);
				return crypto.subtle.importKey(
					'raw',
					keyMaterial,
					{ name: 'PBKDF2' },
					false,
					['deriveKey']
				).then(keyMaterial => {
					return crypto.subtle.deriveKey(
						{
							name: 'PBKDF2',
							salt: saltBuffer,
							iterations: 100000,
							hash: 'SHA-256'
						},
						keyMaterial,
						{
							name: 'AES-CBC',
							length: 256
						},
						true,
						['encrypt', 'decrypt']
					);
				});
			}

			static async encrypt(plaintext, password) {
				const salt = crypto.getRandomValues(new Uint8Array(16));
				const iv = crypto.getRandomValues(new Uint8Array(16));
				const key = await this.generateKey(password, salt);
				const encoder = new TextEncoder();
				const data = encoder.encode(plaintext);
				const encrypted = await crypto.subtle.encrypt(
					{
						name: 'AES-CBC',
						iv: iv
					},
					key,
					data
				);
				return {
					salt: Array.from(salt),
					iv: Array.from(iv),
					encrypted: Array.from(new Uint8Array(encrypted))
				};
			}

			static async decrypt(encryptedData, password) {
				const salt = new Uint8Array(encryptedData.salt);
				const iv = new Uint8Array(encryptedData.iv);
				const data = new Uint8Array(encryptedData.encrypted);
				const key = await this.generateKey(password, salt);
				const decrypted = await crypto.subtle.decrypt(
					{
						name: 'AES-CBC',
						iv: iv
					},
					key,
					data
				);
				const decoder = new TextDecoder();
				return decoder.decode(decrypted);
			}

			static async encryptToBase64(plaintext, password) {
				const encrypted = await this.encrypt(plaintext, password);
				const combined = new Uint8Array(
					1 + 16 + 16 + encrypted.encrypted.length
				);
				combined[0] = 1; // 版本号
				combined.set(encrypted.salt, 1);
				combined.set(encrypted.iv, 1 + 16);
				combined.set(encrypted.encrypted, 1 + 16 + 16);
				return btoa(String.fromCharCode.apply(null, combined));
			}

			static async decryptFromBase64(encryptedBase64, password) {
				const combined = new Uint8Array(
					atob(encryptedBase64).split('').map(char => char.charCodeAt(0))
				);
				const version = combined[0];
				if (version !== 1) {
					throw new Error('不支持的加密版本');
				}
				const salt = combined.slice(1, 1 + 16);
				const iv = combined.slice(1 + 16, 1 + 16 + 16);
				const encrypted = combined.slice(1 + 16 + 16);
				return this.decrypt(
					{
						salt: Array.from(salt),
						iv: Array.from(iv),
						encrypted: Array.from(encrypted)
					},
					password
				);
			}
		}

		// 初始化
		document.addEventListener('DOMContentLoaded', function () {
			// 加载版本信息
			fetch('../js/nav-data.json')
				.then(response => response.json())
				.then(data => {
					loadVersionInfo(data);
				})
				.catch(error => {
					console.error('加载版本信息时出错:', error);
					document.getElementById('uptime1').textContent = 'Beta:error';
					document.getElementById('state1').textContent = 'Error';
				});

			// 检查是否有锁定
			checkLockout();

			// 根据日期打乱图案顺序
			shufflePatternsByDate();

			// 渲染图案按钮
			renderPatternButtons();

			// 绑定事件
			document.getElementById('clear-btn').addEventListener('click', clearPassword);

			// 自动加载MM.json文件
			loadMMFile();
		});

		// 根据日期打乱图案顺序
		function shufflePatternsByDate() {
			const today = new Date();
			const dateString = today.toISOString().split('T')[0];
			const seed = dateString.split('-').reduce((sum, num) => sum + parseInt(num), 0);
			
			// 使用Fisher-Yates洗牌算法，基于日期种子
			patternOrder = ['A', 'B', 'C', 'D'];
			for (let i = patternOrder.length - 1; i > 0; i--) {
				const j = (seed + i) % (i + 1);
				[patternOrder[i], patternOrder[j]] = [patternOrder[j], patternOrder[i]];
			}
		}

		// 渲染图案按钮
		function renderPatternButtons() {
			const container = document.getElementById('pattern-container');
			container.innerHTML = '';

			const patterns = {
				'A': '□',
				'B': '△',
				'C': '◇',
				'D': '★'
			};

			patternOrder.forEach(pattern => {
				const button = document.createElement('button');
				button.className = 'pattern-btn';
				button.textContent = patterns[pattern];
				button.dataset.pattern = pattern;
				button.addEventListener('click', function () {
					if (lockoutUntil) return;
					addPatternToPassword(pattern);
				});
				container.appendChild(button);
			});
		}

		// 添加图案到密码
		function addPatternToPassword(pattern) {
			if (currentPassword.length < 4) {
				currentPassword += pattern;
				updatePasswordDisplay();

				if (currentPassword.length === 4) {
					// 密码输入完成，尝试解密
					attemptDecryption();
				}
			}
		}

		// 更新密码显示
		function updatePasswordDisplay() {
			const display = document.getElementById('password-display');
			display.textContent = '*'.repeat(currentPassword.length) + '_'.repeat(4 - currentPassword.length);
		}

		// 清除密码
		function clearPassword() {
			currentPassword = '';
			updatePasswordDisplay();
			document.getElementById('error-message').textContent = '';
			// 清除错误样式
			document.getElementById('password-display').classList.remove('error');
		}

		// 检查锁定状态
		function checkLockout() {
			const savedLockoutUntil = localStorage.getItem('mmDecryptLockoutUntil');
			if (savedLockoutUntil) {
				lockoutUntil = new Date(parseInt(savedLockoutUntil));
				if (lockoutUntil > new Date()) {
					displayLockoutMessage();
				} else {
					// 锁定时间已过，重置
					resetLockout();
				}
			}

			const savedErrorCount = localStorage.getItem('mmDecryptErrorCount');
			if (savedErrorCount) {
				errorCount = parseInt(savedErrorCount);
			}
		}

		// 显示锁定消息
		function displayLockoutMessage() {
			const remainingTime = Math.ceil((lockoutUntil - new Date()) / (1000 * 60));
			const message = `密码错误次数过多，已锁定。请${remainingTime}分钟后再试。`;
			document.getElementById('lockout-message').textContent = message;

			// 禁用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = true;
				button.style.opacity = '0.5';
			});
		}

		// 重置锁定状态
		function resetLockout() {
			lockoutUntil = null;
			errorCount = 0;
			localStorage.removeItem('mmDecryptLockoutUntil');
			localStorage.removeItem('mmDecryptErrorCount');
			document.getElementById('lockout-message').textContent = '';

			// 启用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = false;
				button.style.opacity = '1';
			});
		}

		// 记录错误
		function recordError() {
			errorCount++;
			localStorage.setItem('mmDecryptErrorCount', errorCount.toString());

			if (errorCount >= MAX_ERRORS) {
				lockoutUntil = new Date(Date.now() + LOCKOUT_DURATION);
				localStorage.setItem('mmDecryptLockoutUntil', lockoutUntil.getTime().toString());
				displayLockoutMessage();
			}

			const message = `密码错误！剩余尝试次数：${Math.max(0, MAX_ERRORS - errorCount)}`;
			document.getElementById('error-message').textContent = message;

			// 应用抖动效果和错误样式
			const passwordDisplay = document.getElementById('password-display');
			passwordDisplay.classList.add('error', 'shake');

			// 移除抖动效果和错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('shake');
			}, 500);

			// 3秒后移除错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('error');
			}, 3000);
		}

		// 加载MM-encrypted.json文件
		function loadMMFile() {
			fetch('MM-encrypted.json')
				.then(response => {
					if (!response.ok) {
						throw new Error('无法加载MM-encrypted.json文件');
					}
					return response.text();
				})
				.then(content => {
					// 文件已加载，等待用户输入密码
				})
				.catch(error => {
					console.error('加载MM-encrypted.json文件时出错:', error);
					document.getElementById('error-message').textContent = '无法加载MM-encrypted.json文件';
				});
		}

		// 尝试解密
		async function attemptDecryption() {
			try {
				// 加载MM-encrypted.json文件
				const response = await fetch('MM-encrypted.json');
				if (!response.ok) {
					throw new Error('无法加载MM-encrypted.json文件');
				}
				const encryptedContent = await response.text();

				// 尝试解密
				let decryptedContent;
				try {
					// 检查是否是加密的JSON
					const parsed = JSON.parse(encryptedContent);
					if (parsed.salt && parsed.iv && parsed.encrypted) {
						// 是加密的JSON
						decryptedContent = await AESUtil.decrypt(parsed, currentPassword);
					} else {
						// 可能已经是明文JSON
						decryptedContent = encryptedContent;
					}
				} catch (e) {
					// 尝试base64解密
					decryptedContent = await AESUtil.decryptFromBase64(encryptedContent, currentPassword);
				}

				// 解密成功
				displayDecryptedContent(decryptedContent);
				resetLockout();
			} catch (error) {
				console.error('解密失败:', error);
				recordError();
				clearPassword();
			}
		}

		// 显示解密后的内容
		function displayDecryptedContent(content) {
			const passwordSection = document.getElementById('password-section');
			const contentSection = document.getElementById('content-section');
			const mmContent = document.getElementById('mm-content');

			// 隐藏密码输入区域，显示内容区域
			passwordSection.style.display = 'none';
			contentSection.style.display = 'block';

			// 解析JSON并显示
			try {
				const data = JSON.parse(content);
				let html = '';

				data.forEach(entry => {
					html += `
						<div class="mm-entry">
							<div class="mm-entry-platform">${entry.platform}</div>
							<div class="mm-entry-account">账号: ${entry.accountType}</div>
							<div class="mm-entry-password">密码模式: ${entry.passwordPattern || '无'}</div>
						</div>
					`;
				});

				mmContent.innerHTML = html;
			} catch (error) {
				console.error('解析JSON失败:', error);
				mmContent.innerHTML = '<div class="alert alert-danger">解析数据失败</div>';
			}
		}

		// 加载版本信息
		function loadVersionInfo(data) {
			if (data.version) {
				document.getElementById('uptime1').textContent = data.version;
			}
			document.getElementById('state1').textContent = 'Online';
		}
	</script>
</body>

</html>