<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Xiaolan - Secure MM</title>
	<!-- 模块化 Header 组件 -->
	<script src="../js/components/header-component.js"></script>
	<link rel="stylesheet" href="../css/manager-styles.css">
	<script type="text/javascript" src="../js/jquery-3.5.1.min.js"></script>
	<style>
		/* 页面特定样式 - 仅保留未标准化的动画 */
		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
			20%, 40%, 60%, 80% { transform: translateX(5px); }
		}

		.shake {
			animation: shake 0.5s ease-in-out;
		}

		/* 图案按钮悬停效果 */
		.pattern-btn:hover {
			transform: scale(1.1);
			border-color: var(--primary-color) !important;
			background-color: var(--bg-light) !important;
		}

		.pattern-btn.selected {
			background-color: var(--primary-color) !important;
			color: white !important;
			border-color: var(--secondary-color) !important;
		}
	</style>
</head>

<body class="overflow-y-hidden">
	<div class="z-3 d-flex flex-row position-fixed">
		<button onclick="window.location.href = '../index.html'" type="button" class="btn btn-info shadow mt-3 mx-3 w-100px"><strong>返回</strong></button>
		<button onclick="window.location.href = 'More.html'" type="button" class="btn btn-info shadow mt-3 w-100px"><strong>More</strong></button>
	</div>

	<div class="z-2 d-flex flex-column mx-auto mt-5 pt-2">
		<!-- 密码输入区域 -->
		<div id="password-section" class="mt-10">
			<div class="password-container mw-500px mx-auto p-4 bg-white rounded-10 shadow-soft">
				<h3 class="text-center mb-4">解密 MM 数据</h3>
				<p class="text-center mb-4">请点击四位数图案密码 (A: □, B: △, C: ◇, D: ★)</p>
				<div class="password-display mb-4" id="password-display">____</div>
				<div class="pattern-container grid-4 grid-sm-2 gap-15 my-4" id="pattern-container"></div>
				<div class="error-message" id="error-message"></div>
				<div class="lockout-message" id="lockout-message"></div>
				<button id="clear-btn" class="btn btn-secondary w-100 mt-2">清除</button>
			</div>
		</div>

		<!-- 解密后内容区域 -->
		<div id="content-section" class="content-container mw-800px mx-auto p-4 d-none">
			<h3 class="text-center mb-4">MM 数据</h3>
			<div id="mm-content"></div>
		</div>

		<div class="fixed-bottom mx-1">
			<div class=" container-fluid">
				<div class="float-end">
					<span class="badge text-black-50">
						<a href="https://xiaolanqqai-sturdy-journey-97xqj446r6wfpw6v.github.dev/" rel="nofollow" target="_blank">Dev</a> • 
						<a id="uptime1" href="Develop.html">加载中...</a>
					</span>
					<span id="state1" class="badge text-bg-success">加载中...</span>
					<a><div class="spinner-grow spinner-grow-sm text-info" role="status"></div></a>
				</div>
			</div>
		</div>
	</div>

	<!-- 模块化 Background 组件 -->
	<script src="../js/components/background-component.js"></script>
	<script>
		$('img').on("error", function () {
			$(this).attr('src', '../img/index.png');
		});
	</script>
	<script src="../js/foot.js"></script>
	<script src="../js/dark-mode.js"></script>


	<!-- 加密解密功能 -->
	<script>
		// 全局变量
		let currentPassword = '';
		let patternOrder = ['A', 'B', 'C', 'D'];
		let errorCount = 0;
		let lockoutUntil = null;
		const MAX_ERRORS = 3;
		const LOCKOUT_DURATION = 24 * 60 * 60 * 1000; // 24小时

		// AES加密解密功能 - 与MM-generator.html保持一致
		class AESUtil {
			// AES-256-CBC加密
			static encrypt(text, password) {
				const encoder = new TextEncoder();
				const textData = encoder.encode(text);
				const passwordData = encoder.encode(password.padEnd(32, ' '));
				
				const iv = crypto.getRandomValues(new Uint8Array(16));
				const salt = crypto.getRandomValues(new Uint8Array(16));
				
				return window.crypto.subtle.importKey(
					'raw',
					passwordData,
					{ name: 'PBKDF2' },
					false,
					['deriveKey']
				).then(key => {
					return window.crypto.subtle.deriveKey(
						{
							name: 'PBKDF2',
							salt: salt,
							iterations: 100000,
							hash: 'SHA-256'
						},
						key,
						{
							name: 'AES-CBC',
							length: 256
						},
						false,
						['encrypt']
					);
				}).then(key => {
					return window.crypto.subtle.encrypt(
						{
							name: 'AES-CBC',
							iv: iv
						},
						key,
						textData
					);
				}).then(encrypted => {
					const encryptedData = new Uint8Array(encrypted);
					const totalLength = salt.length + iv.length + encryptedData.length;
					const combined = new Uint8Array(totalLength);
					
					combined.set(salt, 0);
					combined.set(iv, salt.length);
					combined.set(encryptedData, salt.length + iv.length);
					
					return btoa(String.fromCharCode.apply(null, combined));
				});
			}
			
			// AES-256-CBC解密
			static decrypt(encryptedData, password) {
				const combined = new Uint8Array(atob(encryptedData).split('').map(char => char.charCodeAt(0)));
				const salt = combined.slice(0, 16);
				const iv = combined.slice(16, 32);
				const encrypted = combined.slice(32);
				
				const encoder = new TextEncoder();
				const passwordData = encoder.encode(password.padEnd(32, ' '));
				
				return window.crypto.subtle.importKey(
					'raw',
					passwordData,
					{ name: 'PBKDF2' },
					false,
					['deriveKey']
				).then(key => {
					return window.crypto.subtle.deriveKey(
						{
							name: 'PBKDF2',
							salt: salt,
							iterations: 100000,
							hash: 'SHA-256'
						},
						key,
						{
							name: 'AES-CBC',
							length: 256
						},
						false,
						['decrypt']
					);
				}).then(key => {
					return window.crypto.subtle.decrypt(
						{
							name: 'AES-CBC',
							iv: iv
						},
						key,
						encrypted
					);
				}).then(decrypted => {
					const decoder = new TextDecoder();
					return decoder.decode(decrypted);
				});
			}
		}

		// 初始化
		document.addEventListener('DOMContentLoaded', function () {
			// 加载版本信息
			fetch('../data/nav-data.json')
				.then(response => response.json())
				.then(data => {
					loadVersionInfo(data);
				})
				.catch(error => {
					console.error('加载版本信息时出错:', error);
					document.getElementById('uptime1').textContent = 'Beta:error';
					document.getElementById('state1').textContent = 'Error';
				});

			// 检查是否有锁定
			checkLockout();

			// 根据日期打乱图案顺序
			shufflePatternsByDate();

			// 渲染图案按钮
			renderPatternButtons();

			// 绑定事件
			document.getElementById('clear-btn').addEventListener('click', clearPassword);

			// 自动加载MM.json文件
			loadMMFile();
		});

		// 根据日期打乱图案顺序
		function shufflePatternsByDate() {
			const today = new Date();
			const dateString = today.toISOString().split('T')[0];
			const seed = dateString.split('-').reduce((sum, num) => sum + parseInt(num), 0);
			
			// 使用Fisher-Yates洗牌算法，基于日期种子
			patternOrder = ['A', 'B', 'C', 'D'];
			for (let i = patternOrder.length - 1; i > 0; i--) {
				const j = (seed + i) % (i + 1);
				[patternOrder[i], patternOrder[j]] = [patternOrder[j], patternOrder[i]];
			}
		}

		// 渲染图案按钮
		function renderPatternButtons() {
			const container = document.getElementById('pattern-container');
			container.innerHTML = '';

			const patterns = {
				'A': '□',
				'B': '△',
				'C': '◇',
				'D': '★'
			};

			patternOrder.forEach(pattern => {
				const button = document.createElement('button');
				button.className = 'pattern-btn w-80px h-80px rounded-10 fs-30px w-sm-60px h-sm-60px fs-sm-20px d-flex align-items-center justify-content-center';
				button.textContent = patterns[pattern];
				button.dataset.pattern = pattern;
				button.addEventListener('click', function () {
					if (lockoutUntil) return;
					addPatternToPassword(pattern);
				});
				container.appendChild(button);
			});
		}

		// 添加图案到密码
		function addPatternToPassword(pattern) {
			if (currentPassword.length < 4) {
				currentPassword += pattern;
				updatePasswordDisplay();

				if (currentPassword.length === 4) {
					// 密码输入完成，尝试解密
					attemptDecryption();
				}
			}
		}

		// 更新密码显示
		function updatePasswordDisplay() {
			const display = document.getElementById('password-display');
			display.textContent = '*'.repeat(currentPassword.length) + '_'.repeat(4 - currentPassword.length);
		}

		// 清除密码
		function clearPassword() {
			currentPassword = '';
			updatePasswordDisplay();
			document.getElementById('error-message').textContent = '';
			// 清除错误样式
			document.getElementById('password-display').classList.remove('error');
		}

		// 检查锁定状态
		function checkLockout() {
			const savedLockoutUntil = localStorage.getItem('mmDecryptLockoutUntil');
			if (savedLockoutUntil) {
				lockoutUntil = new Date(parseInt(savedLockoutUntil));
				if (lockoutUntil > new Date()) {
					displayLockoutMessage();
				} else {
					// 锁定时间已过，重置
					resetLockout();
				}
			}

			const savedErrorCount = localStorage.getItem('mmDecryptErrorCount');
			if (savedErrorCount) {
				errorCount = parseInt(savedErrorCount);
			}
		}

		// 显示锁定消息
		function displayLockoutMessage() {
			const remainingTime = Math.ceil((lockoutUntil - new Date()) / (1000 * 60));
			const message = `密码错误次数过多，已锁定。请${remainingTime}分钟后再试。`;
			document.getElementById('lockout-message').textContent = message;

			// 禁用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = true;
				button.style.opacity = '0.5';
			});
		}

		// 重置锁定状态
		function resetLockout() {
			lockoutUntil = null;
			errorCount = 0;
			localStorage.removeItem('mmDecryptLockoutUntil');
			localStorage.removeItem('mmDecryptErrorCount');
			document.getElementById('lockout-message').textContent = '';

			// 启用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = false;
				button.style.opacity = '1';
			});
		}

		// 记录错误
		function recordError() {
			errorCount++;
			localStorage.setItem('mmDecryptErrorCount', errorCount.toString());

			if (errorCount >= MAX_ERRORS) {
				lockoutUntil = new Date(Date.now() + LOCKOUT_DURATION);
				localStorage.setItem('mmDecryptLockoutUntil', lockoutUntil.getTime().toString());
				displayLockoutMessage();
			}

			const message = `密码错误！剩余尝试次数：${Math.max(0, MAX_ERRORS - errorCount)}`;
			document.getElementById('error-message').textContent = message;

			// 应用抖动效果和错误样式
			const passwordDisplay = document.getElementById('password-display');
			passwordDisplay.classList.add('error', 'shake');

			// 移除抖动效果和错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('shake');
			}, 500);

			// 3秒后移除错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('error');
			}, 3000);
		}

		// 加载MM.json文件
		function loadMMFile() {
			fetch('../data/MM.json')
				.then(response => {
					if (!response.ok) {
						throw new Error('无法加载MM.json文件');
					}
					return response.text();
				})
				.then(content => {
					// 文件已加载，等待用户输入密码
				})
				.catch(error => {
					console.error('加载MM.json文件时出错:', error);
					document.getElementById('error-message').textContent = '无法加载MM.json文件';
				});
		}

		// 尝试解密
		async function attemptDecryption() {
			console.log('开始尝试解密，当前密码:', currentPassword);
			try {
				// 加载MM.json文件
				const response = await fetch('../data/MM.json?t=' + new Date().getTime());
				if (!response.ok) {
					throw new Error('无法加载MM.json文件');
				}
				
				// 读取为ArrayBuffer以处理二进制数据
				const arrayBuffer = await response.arrayBuffer();
				let encryptedContent = '';
				
				// 尝试解码为文本
				const textContent = new TextDecoder().decode(arrayBuffer);
				
				// 检查是否包含二进制数据
				function containsBinaryData(str) {
					return /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F\ufffd]/.test(str);
				}
				
				let isBinary = containsBinaryData(textContent);
				if (!isBinary) {
					try {
						// 尝试atob，如果失败说明不是有效的Base64，那可能是二进制（或者明文）
						// 但如果是加密的，必须是Base64。如果不是Base64，说明是原始二进制加密数据。
						// 忽略空白字符
						const cleanStr = textContent.replace(/\s/g, '');
						if (cleanStr.length > 0) {
							atob(cleanStr);
						}
					} catch (e) {
						console.log('atob失败，判定为二进制数据');
						isBinary = true;
					}
				}
				
				if (isBinary) {
					console.log('检测到二进制数据，转换为Base64...');
					const binaryStr = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
					encryptedContent = btoa(binaryStr);
				} else {
					encryptedContent = textContent;
					// 检查并移除data URL前缀
					if (encryptedContent.startsWith('data:application/json;base64,')) {
						console.log('检测到data URL前缀，移除它...');
						encryptedContent = encryptedContent.replace('data:application/json;base64,', '');
					}
				}

				console.log('处理后的内容长度:', encryptedContent.length);
				console.log('文件内容前50个字符:', encryptedContent.substring(0, 50));

				// 尝试解密
				let decryptedContent;
				try {
					// 直接使用AESUtil.decrypt解密，因为MM.json是base64加密的
					console.log('开始解密...');
					decryptedContent = await AESUtil.decrypt(encryptedContent, currentPassword);
					console.log('解密成功，解密内容:', decryptedContent);
				} catch (e) {
					console.error('解密失败:', e);
					// 如果解密失败，可能是明文JSON
					try {
						console.log('尝试解析为明文JSON...');
						JSON.parse(encryptedContent);
						decryptedContent = encryptedContent;
						console.log('解析明文JSON成功');
					} catch (jsonError) {
						console.error('解析明文JSON也失败:', jsonError);
						// 不是明文JSON，解密确实失败
						throw e;
					}
				}

				// 解密成功
				console.log('准备显示解密内容');
				displayDecryptedContent(decryptedContent);
				resetLockout();
			} catch (error) {
				console.error('整体解密流程失败:', error);
				recordError();
				clearPassword();
			}
		}

		// 显示解密后的内容
		function displayDecryptedContent(content) {
			const passwordSection = document.getElementById('password-section');
			const contentSection = document.getElementById('content-section');
			const mmContent = document.getElementById('mm-content');

			// 隐藏密码输入区域，显示内容区域
			passwordSection.classList.add('d-none');
			contentSection.classList.remove('d-none');
			
			// 允许页面滚动
			document.body.classList.remove('overflow-y-hidden');
			document.body.style.overflowY = 'auto';

			// 解析JSON并显示
			try {
				const data = JSON.parse(content);
				let html = '';
				
				// 设置容器为Grid布局
				mmContent.className = 'row g-3';

				data.forEach(entry => {
					html += `
						<div class="col-12 col-md-6 col-lg-4">
							<div class="card h-100 shadow-sm border-0 bg-white">
								<div class="card-body">
									<h5 class="card-title text-primary border-bottom pb-2 mb-3">
										<i class="fas fa-globe me-2"></i>${entry.platform}
									</h5>
									<p class="card-text mb-2">
										<i class="fas fa-user me-2 text-secondary"></i>
										<strong>账号:</strong> ${entry.accountType}
									</p>
									<p class="card-text">
										<i class="fas fa-key me-2 text-secondary"></i>
										<strong>模式:</strong> <span class="badge bg-info text-dark">${entry.passwordPattern || '无'}</span>
									</p>
								</div>
							</div>
						</div>
					`;
				});

				mmContent.innerHTML = html;
			} catch (error) {
				console.error('解析JSON失败:', error);
				mmContent.innerHTML = '<div class="alert alert-danger w-100">解析数据失败</div>';
			}
		}

		// 加载版本信息
		function loadVersionInfo(data) {
			if (data.version) {
				// version是一个对象，包含web_vol和web_data属性
				const versionText = `${data.version.web_vol}`;
				document.getElementById('uptime1').textContent = versionText;
			}
			document.getElementById('state1').textContent = 'Online';
		}
	</script>
</body>

</html>