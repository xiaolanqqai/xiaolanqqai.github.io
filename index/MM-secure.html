<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Xiaolan - Secure MM</title>
	<link rel="Shortcut icon" href="../favicon.ico" loading="lazy">
	<link rel="stylesheet" href="../css/bootstrap.min.css">
	<script type="text/javascript" src="../js/jquery-3.5.1.min.js"></script>
	<link rel="stylesheet" type="text/css" href="../css/index.css" />
	<link rel="stylesheet" type="text/css" href="../css/dark-mode.css" />
	<style>
		/* 密码输入区域样式 */
		.password-container {
			max-width: 500px;
			margin: 0 auto;
			padding: 20px;
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 10px;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
		}

		.pattern-container {
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			gap: 15px;
			margin: 20px 0;
		}

		.pattern-btn {
			width: 80px;
			height: 80px;
			border-radius: 10px;
			font-size: 30px;
			cursor: pointer;
			border: 2px solid #ddd;
			background-color: #f8f9fa;
			transition: all 0.3s ease;
		}

		.pattern-btn:hover {
			transform: scale(1.1);
			border-color: #0d6efd;
			background-color: #e7f3ff;
		}

		.pattern-btn.selected {
			background-color: #0d6efd;
			color: white;
			border-color: #0a58ca;
		}

		/* 密码显示区域样式更新 */
		.password-display {
			font-size: 32px;
			text-align: center;
			margin: 20px 0;
			letter-spacing: 15px;
			font-family: monospace;
			padding: 15px;
			border: 2px solid #ced4da;
			border-radius: 8px;
			background-color: #f8f9fa;
			color: #495057;
			transition: all 0.3s ease;
			min-height: 60px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		/* 错误状态下的密码显示区域 */
		.password-display.error {
			border-color: #dc3545;
			background-color: #fff5f5;
			color: #dc3545;
			box-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
		}

		/* 抖动动画 */
		@keyframes shake {
			0%, 100% { transform: translateX(0); }
			10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
			20%, 40%, 60%, 80% { transform: translateX(5px); }
		}

		/* 抖动效果类 */
		.shake {
			animation: shake 0.5s ease-in-out;
		}

		.error-message {
			color: #dc3545;
			text-align: center;
			margin: 10px 0;
			font-weight: 500;
		}

		.lockout-message {
			color: #dc3545;
			text-align: center;
			margin: 10px 0;
			font-weight: bold;
		}

		/* 解密后内容样式 */
		.content-container {
			max-width: 800px;
			margin: 0 auto;
			padding: 20px;
		}

		.mm-entry {
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 8px;
			padding: 15px;
			margin: 10px 0;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		}

		.mm-entry-platform {
			font-size: 18px;
			font-weight: bold;
			color: #0d6efd;
			margin-bottom: 5px;
		}

		.mm-entry-account {
			font-size: 16px;
			margin-bottom: 5px;
		}

		.mm-entry-password {
			font-size: 14px;
			color: #6c757d;
			font-style: italic;
		}

		/* 响应式设计 */
		@media (max-width: 576px) {
			.pattern-container {
				grid-template-columns: repeat(2, 1fr);
			}

			.pattern-btn {
				width: 60px;
				height: 60px;
				font-size: 20px;
			}
		}
	</style>
</head>

<body style="overflow-y: hidden">
	<div class="z-3 d-flex flex-row position-fixed">
		<button onclick="window.location.href = '../index.html'" type="button" class="btn btn-info shadow mt-3 mx-3" style="width: 100px;"><strong>返回</strong></button>
		<button onclick="window.location.href = 'More.html'" type="button" class="btn btn-info shadow mt-3" style="width: 100px;"><strong>More</strong></button>
	</div>

	<div class="z-2 d-flex flex-column mx-auto mt-5 pt-2">
		<!-- 密码输入区域 -->
		<div id="password-section" class="mt-10">
			<div class="password-container">
				<h3 class="text-center mb-4">解密 MM 数据</h3>
				<p class="text-center mb-4">请点击四位数图案密码 (A: □, B: △, C: ◇, D: ★)</p>
				<div class="password-display" id="password-display">____</div>
				<div class="pattern-container" id="pattern-container"></div>
				<div class="error-message" id="error-message"></div>
				<div class="lockout-message" id="lockout-message"></div>
				<button id="clear-btn" class="btn btn-secondary w-100 mt-2">清除</button>
			</div>
		</div>

		<!-- 解密后内容区域 -->
		<div id="content-section" class="content-container" style="display: none;">
			<h3 class="text-center mb-4">MM 数据</h3>
			<div id="mm-content"></div>
		</div>

		<div class="fixed-bottom mx-1">
			<div class=" container-fluid">
				<div class="float-end">
					<span class="badge text-black-50">
						<a href="https://xiaolanqqai-sturdy-journey-97xqj446r6wfpw6v.github.dev/" rel="nofollow" target="_blank">Dev</a> • 
						<a id="uptime1" href="Develop.html">加载中...</a>
					</span>
					<span id="state1" class="badge text-bg-success">加载中...</span>
					<a><div class="spinner-grow spinner-grow-sm text-info" role="status"></div></a>
				</div>
			</div>
		</div>
	</div>

	<!-- 动态背景 -->
	<div class="z-1">
		<div class="z-4">
			<div id="jsi-flying-fish-container" class="w-100"></div>
		</div>
		<canvas class="background"></canvas>
	</div>
	<script src="../js/particles.min.js"></script>
	<script src="../js/fish.js"></script>
	<script>
		$('img').on("error", function () {
			$(this).attr('src', '../img/index.png');
		});
	</script>
	<script src="../js/foot.js"></script>
	<script src="../js/dark-mode.js"></script>


	<!-- 加密解密功能 -->
	<script>
		// 全局变量
		let currentPassword = '';
		let patternOrder = ['A', 'B', 'C', 'D'];
		let errorCount = 0;
		let lockoutUntil = null;
		const MAX_ERRORS = 3;
		const LOCKOUT_DURATION = 24 * 60 * 60 * 1000; // 24小时

		// AES加密解密功能 - 与MM-generator.html保持一致
		class AESUtil {
			// AES-256-CBC加密
			static encrypt(text, password) {
				const encoder = new TextEncoder();
				const textData = encoder.encode(text);
				const passwordData = encoder.encode(password.padEnd(32, ' '));
				
				const iv = crypto.getRandomValues(new Uint8Array(16));
				const salt = crypto.getRandomValues(new Uint8Array(16));
				
				return window.crypto.subtle.importKey(
					'raw',
					passwordData,
					{ name: 'PBKDF2' },
					false,
					['deriveKey']
				).then(key => {
					return window.crypto.subtle.deriveKey(
						{
							name: 'PBKDF2',
							salt: salt,
							iterations: 100000,
							hash: 'SHA-256'
						},
						key,
						{
							name: 'AES-CBC',
							length: 256
						},
						false,
						['encrypt']
					);
				}).then(key => {
					return window.crypto.subtle.encrypt(
						{
							name: 'AES-CBC',
							iv: iv
						},
						key,
						textData
					);
				}).then(encrypted => {
					const encryptedData = new Uint8Array(encrypted);
					const totalLength = salt.length + iv.length + encryptedData.length;
					const combined = new Uint8Array(totalLength);
					
					combined.set(salt, 0);
					combined.set(iv, salt.length);
					combined.set(encryptedData, salt.length + iv.length);
					
					return btoa(String.fromCharCode.apply(null, combined));
				});
			}
			
			// AES-256-CBC解密
			static decrypt(encryptedData, password) {
				const combined = new Uint8Array(atob(encryptedData).split('').map(char => char.charCodeAt(0)));
				const salt = combined.slice(0, 16);
				const iv = combined.slice(16, 32);
				const encrypted = combined.slice(32);
				
				const encoder = new TextEncoder();
				const passwordData = encoder.encode(password.padEnd(32, ' '));
				
				return window.crypto.subtle.importKey(
					'raw',
					passwordData,
					{ name: 'PBKDF2' },
					false,
					['deriveKey']
				).then(key => {
					return window.crypto.subtle.deriveKey(
						{
							name: 'PBKDF2',
							salt: salt,
							iterations: 100000,
							hash: 'SHA-256'
						},
						key,
						{
							name: 'AES-CBC',
							length: 256
						},
						false,
						['decrypt']
					);
				}).then(key => {
					return window.crypto.subtle.decrypt(
						{
							name: 'AES-CBC',
							iv: iv
						},
						key,
						encrypted
					);
				}).then(decrypted => {
					const decoder = new TextDecoder();
					return decoder.decode(decrypted);
				});
			}
		}

		// 初始化
		document.addEventListener('DOMContentLoaded', function () {
			// 加载版本信息
			fetch('../js/nav-data.json')
				.then(response => response.json())
				.then(data => {
					loadVersionInfo(data);
				})
				.catch(error => {
					console.error('加载版本信息时出错:', error);
					document.getElementById('uptime1').textContent = 'Beta:error';
					document.getElementById('state1').textContent = 'Error';
				});

			// 检查是否有锁定
			checkLockout();

			// 根据日期打乱图案顺序
			shufflePatternsByDate();

			// 渲染图案按钮
			renderPatternButtons();

			// 绑定事件
			document.getElementById('clear-btn').addEventListener('click', clearPassword);

			// 自动加载MM.json文件
			loadMMFile();
		});

		// 根据日期打乱图案顺序
		function shufflePatternsByDate() {
			const today = new Date();
			const dateString = today.toISOString().split('T')[0];
			const seed = dateString.split('-').reduce((sum, num) => sum + parseInt(num), 0);
			
			// 使用Fisher-Yates洗牌算法，基于日期种子
			patternOrder = ['A', 'B', 'C', 'D'];
			for (let i = patternOrder.length - 1; i > 0; i--) {
				const j = (seed + i) % (i + 1);
				[patternOrder[i], patternOrder[j]] = [patternOrder[j], patternOrder[i]];
			}
		}

		// 渲染图案按钮
		function renderPatternButtons() {
			const container = document.getElementById('pattern-container');
			container.innerHTML = '';

			const patterns = {
				'A': '□',
				'B': '△',
				'C': '◇',
				'D': '★'
			};

			patternOrder.forEach(pattern => {
				const button = document.createElement('button');
				button.className = 'pattern-btn';
				button.textContent = patterns[pattern];
				button.dataset.pattern = pattern;
				button.addEventListener('click', function () {
					if (lockoutUntil) return;
					addPatternToPassword(pattern);
				});
				container.appendChild(button);
			});
		}

		// 添加图案到密码
		function addPatternToPassword(pattern) {
			if (currentPassword.length < 4) {
				currentPassword += pattern;
				updatePasswordDisplay();

				if (currentPassword.length === 4) {
					// 密码输入完成，尝试解密
					attemptDecryption();
				}
			}
		}

		// 更新密码显示
		function updatePasswordDisplay() {
			const display = document.getElementById('password-display');
			display.textContent = '*'.repeat(currentPassword.length) + '_'.repeat(4 - currentPassword.length);
		}

		// 清除密码
		function clearPassword() {
			currentPassword = '';
			updatePasswordDisplay();
			document.getElementById('error-message').textContent = '';
			// 清除错误样式
			document.getElementById('password-display').classList.remove('error');
		}

		// 检查锁定状态
		function checkLockout() {
			const savedLockoutUntil = localStorage.getItem('mmDecryptLockoutUntil');
			if (savedLockoutUntil) {
				lockoutUntil = new Date(parseInt(savedLockoutUntil));
				if (lockoutUntil > new Date()) {
					displayLockoutMessage();
				} else {
					// 锁定时间已过，重置
					resetLockout();
				}
			}

			const savedErrorCount = localStorage.getItem('mmDecryptErrorCount');
			if (savedErrorCount) {
				errorCount = parseInt(savedErrorCount);
			}
		}

		// 显示锁定消息
		function displayLockoutMessage() {
			const remainingTime = Math.ceil((lockoutUntil - new Date()) / (1000 * 60));
			const message = `密码错误次数过多，已锁定。请${remainingTime}分钟后再试。`;
			document.getElementById('lockout-message').textContent = message;

			// 禁用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = true;
				button.style.opacity = '0.5';
			});
		}

		// 重置锁定状态
		function resetLockout() {
			lockoutUntil = null;
			errorCount = 0;
			localStorage.removeItem('mmDecryptLockoutUntil');
			localStorage.removeItem('mmDecryptErrorCount');
			document.getElementById('lockout-message').textContent = '';

			// 启用所有图案按钮
			const buttons = document.querySelectorAll('.pattern-btn');
			buttons.forEach(button => {
				button.disabled = false;
				button.style.opacity = '1';
			});
		}

		// 记录错误
		function recordError() {
			errorCount++;
			localStorage.setItem('mmDecryptErrorCount', errorCount.toString());

			if (errorCount >= MAX_ERRORS) {
				lockoutUntil = new Date(Date.now() + LOCKOUT_DURATION);
				localStorage.setItem('mmDecryptLockoutUntil', lockoutUntil.getTime().toString());
				displayLockoutMessage();
			}

			const message = `密码错误！剩余尝试次数：${Math.max(0, MAX_ERRORS - errorCount)}`;
			document.getElementById('error-message').textContent = message;

			// 应用抖动效果和错误样式
			const passwordDisplay = document.getElementById('password-display');
			passwordDisplay.classList.add('error', 'shake');

			// 移除抖动效果和错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('shake');
			}, 500);

			// 3秒后移除错误样式
			setTimeout(() => {
				passwordDisplay.classList.remove('error');
			}, 3000);
		}

		// 加载MM.json文件
		function loadMMFile() {
			fetch('../js/MM.json')
				.then(response => {
					if (!response.ok) {
						throw new Error('无法加载MM.json文件');
					}
					return response.text();
				})
				.then(content => {
					// 文件已加载，等待用户输入密码
				})
				.catch(error => {
					console.error('加载MM.json文件时出错:', error);
					document.getElementById('error-message').textContent = '无法加载MM.json文件';
				});
		}

		// 尝试解密
		async function attemptDecryption() {
			console.log('开始尝试解密，当前密码:', currentPassword);
			try {
				// 加载MM.json文件
				const response = await fetch('../js/MM.json');
				if (!response.ok) {
					throw new Error('无法加载MM.json文件');
				}
				let encryptedContent = await response.text();
				console.log('MM.json文件内容长度:', encryptedContent.length);
				console.log('文件内容前50个字符:', encryptedContent.substring(0, 50));

				// 检查并移除data URL前缀
				if (encryptedContent.startsWith('data:application/json;base64,')) {
					console.log('检测到data URL前缀，移除它...');
					encryptedContent = encryptedContent.replace('data:application/json;base64,', '');
					console.log('移除前缀后的内容长度:', encryptedContent.length);
					console.log('移除前缀后的内容前50个字符:', encryptedContent.substring(0, 50));
				}

				// 尝试解密
				let decryptedContent;
				try {
					// 直接使用AESUtil.decrypt解密，因为MM.json是base64加密的
					console.log('开始解密...');
					decryptedContent = await AESUtil.decrypt(encryptedContent, currentPassword);
					console.log('解密成功，解密内容:', decryptedContent);
				} catch (e) {
					console.error('解密失败:', e);
					// 如果解密失败，可能是明文JSON
					try {
						console.log('尝试解析为明文JSON...');
						JSON.parse(encryptedContent);
						decryptedContent = encryptedContent;
						console.log('解析明文JSON成功');
					} catch (jsonError) {
						console.error('解析明文JSON也失败:', jsonError);
						// 不是明文JSON，解密确实失败
						throw e;
					}
				}

				// 解密成功
				console.log('准备显示解密内容');
				displayDecryptedContent(decryptedContent);
				resetLockout();
			} catch (error) {
				console.error('整体解密流程失败:', error);
				recordError();
				clearPassword();
			}
		}

		// 显示解密后的内容
		function displayDecryptedContent(content) {
			const passwordSection = document.getElementById('password-section');
			const contentSection = document.getElementById('content-section');
			const mmContent = document.getElementById('mm-content');

			// 隐藏密码输入区域，显示内容区域
			passwordSection.style.display = 'none';
			contentSection.style.display = 'block';

			// 解析JSON并显示
			try {
				const data = JSON.parse(content);
				let html = '';

				data.forEach(entry => {
					html += `
						<div class="mm-entry">
							<div class="mm-entry-platform">${entry.platform}</div>
							<div class="mm-entry-account">账号: ${entry.accountType}</div>
							<div class="mm-entry-password">密码模式: ${entry.passwordPattern || '无'}</div>
						</div>
					`;
				});

				mmContent.innerHTML = html;
			} catch (error) {
				console.error('解析JSON失败:', error);
				mmContent.innerHTML = '<div class="alert alert-danger">解析数据失败</div>';
			}
		}

		// 加载版本信息
		function loadVersionInfo(data) {
			if (data.version) {
				// version是一个对象，包含web_vol和web_data属性
				const versionText = `${data.version.web_vol}`;
				document.getElementById('uptime1').textContent = versionText;
			}
			document.getElementById('state1').textContent = 'Online';
		}
	</script>
</body>

</html>